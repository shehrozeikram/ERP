const mongoose = require('mongoose');

const journalEntrySchema = new mongoose.Schema({
  entryNumber: {
    type: String,
    required: [true, 'Entry number is required'],
    unique: true,
    trim: true
  },
  date: {
    type: Date,
    required: [true, 'Entry date is required'],
    default: Date.now
  },
  reference: {
    type: String,
    trim: true,
    maxlength: [100, 'Reference cannot exceed 100 characters']
  },
  description: {
    type: String,
    required: [true, 'Description is required'],
    trim: true,
    maxlength: [500, 'Description cannot exceed 500 characters']
  },
  // Department and module integration
  department: {
    type: String,
    enum: ['hr', 'admin', 'procurement', 'sales', 'finance', 'audit', 'general'],
    required: [true, 'Department is required']
  },
  module: {
    type: String,
    enum: ['payroll', 'procurement', 'sales', 'hr', 'admin', 'audit', 'general'],
    required: [true, 'Module is required']
  },
  referenceId: {
    type: mongoose.Schema.Types.ObjectId,
    required: false // Optional reference to source document
  },
  referenceType: {
    type: String,
    enum: ['payroll', 'invoice', 'bill', 'payment', 'receipt', 'adjustment', 'manual'],
    default: 'manual'
  },
  // Journal entry lines
  lines: [{
    account: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Account',
      required: [true, 'Account is required for each line']
    },
    description: {
      type: String,
      trim: true,
      maxlength: [200, 'Line description cannot exceed 200 characters']
    },
    debit: {
      type: Number,
      default: 0,
      min: [0, 'Debit amount cannot be negative'],
      get: function(val) {
        return Math.round(val * 100) / 100;
      },
      set: function(val) {
        return Math.round(val * 100) / 100;
      }
    },
    credit: {
      type: Number,
      default: 0,
      min: [0, 'Credit amount cannot be negative'],
      get: function(val) {
        return Math.round(val * 100) / 100;
      },
      set: function(val) {
        return Math.round(val * 100) / 100;
      }
    },
    department: {
      type: String,
      enum: ['hr', 'admin', 'procurement', 'sales', 'finance', 'audit', 'general'],
      default: 'general'
    }
  }],
  // Totals (calculated)
  totalDebits: {
    type: Number,
    default: 0,
    get: function(val) {
      return Math.round(val * 100) / 100;
    },
    set: function(val) {
      return Math.round(val * 100) / 100;
    }
  },
  totalCredits: {
    type: Number,
    default: 0,
    get: function(val) {
      return Math.round(val * 100) / 100;
    },
    set: function(val) {
      return Math.round(val * 100) / 100;
    }
  },
  // Status and approval
  status: {
    type: String,
    enum: ['draft', 'posted', 'reversed', 'cancelled'],
    default: 'draft'
  },
  isAutoGenerated: {
    type: Boolean,
    default: false
  },
  reversalOf: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'JournalEntry'
  },
  reversedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'JournalEntry'
  },
  // Metadata
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Created by user is required']
  },
  approvedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  approvalDate: Date,
  postedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  postedDate: Date,
  notes: String,
  attachments: [{
    filename: String,
    originalName: String,
    path: String,
    uploadedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    }
  }]
}, {
  timestamps: true
});

// Indexes
journalEntrySchema.index({ entryNumber: 1 });
journalEntrySchema.index({ date: 1 });
journalEntrySchema.index({ department: 1 });
journalEntrySchema.index({ module: 1 });
journalEntrySchema.index({ referenceId: 1 });
journalEntrySchema.index({ status: 1 });
journalEntrySchema.index({ createdBy: 1 });
journalEntrySchema.index({ 'lines.account': 1 });

// Virtual for balance check
journalEntrySchema.virtual('isBalanced').get(function() {
  return Math.abs(this.totalDebits - this.totalCredits) < 0.01;
});

// Virtual for formatted totals
journalEntrySchema.virtual('formattedTotalDebits').get(function() {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD'
  }).format(this.totalDebits);
});

journalEntrySchema.virtual('formattedTotalCredits').get(function() {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD'
  }).format(this.totalCredits);
});

// Pre-save middleware to calculate totals and validate
journalEntrySchema.pre('save', async function(next) {
  try {
    // Calculate totals
    this.totalDebits = this.lines.reduce((sum, line) => sum + line.debit, 0);
    this.totalCredits = this.lines.reduce((sum, line) => sum + line.credit, 0);

    // Validate double-entry accounting
    if (Math.abs(this.totalDebits - this.totalCredits) > 0.01) {
      return next(new Error('Journal entry is not balanced. Total debits must equal total credits.'));
    }

    // Validate that each line has either debit or credit, not both
    for (let line of this.lines) {
      if (line.debit > 0 && line.credit > 0) {
        return next(new Error('Each journal entry line must have either a debit or credit, not both.'));
      }
      if (line.debit === 0 && line.credit === 0) {
        return next(new Error('Each journal entry line must have either a debit or credit amount.'));
      }
    }

    // Auto-generate entry number if not provided
    if (!this.entryNumber) {
      const count = await this.constructor.countDocuments();
      this.entryNumber = `JE-${(count + 1).toString().padStart(6, '0')}`;
    }

    // Set posted date if status is posted
    if (this.status === 'posted' && !this.postedDate) {
      this.postedDate = new Date();
    }

    next();
  } catch (error) {
    next(error);
  }
});

// Post-save middleware to update account balances when posted
journalEntrySchema.post('save', async function(doc, next) {
  try {
    if (doc.status === 'posted') {
      const Account = mongoose.model('Account');
      
      for (let line of doc.lines) {
        await Account.findByIdAndUpdate(
          line.account,
          {
            $inc: { balance: line.debit - line.credit }
          }
        );
      }
    }
    next();
  } catch (error) {
    next(error);
  }
});

// Static methods
journalEntrySchema.statics.findByDepartment = function(department) {
  return this.find({ department, status: 'posted' });
};

journalEntrySchema.statics.findByModule = function(module) {
  return this.find({ module, status: 'posted' });
};

journalEntrySchema.statics.findByDateRange = function(startDate, endDate) {
  return this.find({
    date: { $gte: startDate, $lte: endDate },
    status: 'posted'
  });
};

journalEntrySchema.statics.findByAccount = function(accountId) {
  return this.find({
    'lines.account': accountId,
    status: 'posted'
  });
};

journalEntrySchema.statics.getGeneralLedger = async function(filters = {}) {
  const query = { status: 'posted', ...filters };
  const entries = await this.find(query)
    .populate('lines.account', 'accountNumber name type')
    .populate('createdBy', 'firstName lastName')
    .sort({ date: 1, entryNumber: 1 });

  return entries;
};

journalEntrySchema.statics.getTrialBalance = async function(asOfDate = new Date()) {
  const Account = mongoose.model('Account');
  const accounts = await Account.find({ isActive: true });

  const trialBalance = await Promise.all(
    accounts.map(async (account) => {
      const entries = await this.find({
        'lines.account': account._id,
        status: 'posted',
        date: { $lte: asOfDate }
      });

      const balance = entries.reduce((sum, entry) => {
        const line = entry.lines.find(l => l.account.toString() === account._id.toString());
        return sum + (line ? line.debit - line.credit : 0);
      }, 0);

      return {
        account: account,
        balance: balance,
        debitBalance: balance > 0 ? balance : 0,
        creditBalance: balance < 0 ? Math.abs(balance) : 0
      };
    })
  );

  return trialBalance.filter(item => item.balance !== 0);
};

// Instance methods
journalEntrySchema.methods.post = async function(postingUser) {
  if (this.status !== 'draft') {
    throw new Error('Only draft entries can be posted');
  }

  if (!this.isBalanced) {
    throw new Error('Entry must be balanced before posting');
  }

  this.status = 'posted';
  this.postedBy = postingUser;
  this.postedDate = new Date();

  return this.save();
};

journalEntrySchema.methods.reverse = async function(reversalUser, reversalReason) {
  if (this.status !== 'posted') {
    throw new Error('Only posted entries can be reversed');
  }

  // Create reversal entry
  const reversalEntry = new this.constructor({
    date: new Date(),
    reference: `REV-${this.entryNumber}`,
    description: `Reversal of ${this.entryNumber}: ${reversalReason}`,
    department: this.department,
    module: this.module,
    referenceId: this._id,
    referenceType: 'adjustment',
    lines: this.lines.map(line => ({
      account: line.account,
      description: line.description,
      debit: line.credit, // Reverse the amounts
      credit: line.debit,
      department: line.department
    })),
    createdBy: reversalUser,
    isAutoGenerated: true,
    reversalOf: this._id
  });

  await reversalEntry.post(reversalUser);
  
  // Mark original entry as reversed
  this.status = 'reversed';
  this.reversedBy = reversalEntry._id;
  await this.save();

  return reversalEntry;
};

module.exports = mongoose.model('JournalEntry', journalEntrySchema);
